#include<iostream>
#include<string>
#include<ctime>
#include<math.h>

//делал в попыхах, так что возможно что-то работать не будет, вам квест)

void Foo1()
{
	cout << "Вызов функции Foo1" << endl;
}

void Foo2()
{
	cout << "Вызов функции Foo2" << endl;
}

int Foo3(int a)
{
	return a - 1;
}

int Foo4(int a)
{
	return a * 2;
}

string DataFromBD()
{
	return "Data From BD";
}

string DataFromWeb()
{
	return "Data from Web";
}

void ShowInfo(bool isFromBD)
{
	if (isFromBD)
	{
		cout << DataFromBD() << endl;
	}
	else
	{
		cout << DataFromWeb() << endl;
	}
}

void ShowInfo(string(*fooPointerExample)())
{
	cout << fooPointerExample() << endl;
}




//define позволяет нам заменять какую либо часть на букавки, что нам удобнее, например 
#define PI 3.14 //вместо того чтобы вечно писать 3.14 мы будем писать PI и будем понимать что мы имеем число пи
#define MATH_TIMES(x, y) ((x)*(y))


using namespace std;

void main()
{
	setlocale(LC_ALL, "Rus");
	srand(time(NULL));

	cout << "указатели на функцию" << endl;
	//можно сказать так, это переменная которой можно присвоить ф-ию, и потом через эту переменную ее вызвать
	//используя такую фигнюшку можно добиться эффукта схожего с полиморфизмом в ООП, но пока просто рассмотрим полиморфизм поверхностно
	//что сейчас для нас полиморфизм, это возможность написать ф-ию, котороая будет что-то делть, но мы даже знать не будем что она делает
	//это будет зависить от параметров которые она принимает
	//СИНТАКСИС

	//тип_ф-ии(*имя указателя)(спецификация параметров);

	//отличие указателя в том что он даже больше смахивает на прототип ф-ии, тем что в указателе на ф-ию нам никогда не придется писать ее реал-ию
	//для начала создадим указатель на ф-ию типа void

	void (*fooPointer)();//вот оно, но он ничего не делает, так как не принимает значения
	//наверху есть функции Foo1 и Foo2, каким же образом их нам вывести через указатель? просто

	fooPointer = Foo1;//всё
	fooPointer();//теперь все спокойно вызовется

	fooPointer = Foo2;//хоба
	fooPointer();

	//навурху 2 функции: Foo3 Foo4. одна выводит a-1, другая a*2, все это сделаем через указатель на ф-ию

	int (*fooMathPointer)(int a);
	fooMathPointer = Foo3;
	cout << fooMathPointer(5) << endl;
	fooMathPointer = Foo4;
	cout << fooMathPointer(5) << endl;
	//конечно так никто не делает, это просто тупо. однако указатель на ф-ию важен
	//допустим вы работаете в конторе что делает ПО. Вы делаете голографический монитор, и перед вами задача выводить данные на такой монитор
	//допустим у вас 2 коллеги, один пишет ф-ию	которая будет получать данные из базы данных удаленно, которые вы потом должны вывести
	//второй делает ф-ию для того чтобы получать данные из интеренета
	//наверху ф-я ShowInfo
	//ваши коллеги работали и первый кто сделал это как раз ту базу даннных (наверху string DataFromBD)
	//потом подтянулся второй (наверху string DataFromWeb)
	//у вас появилась проблема, надо как-то реализовать в вашей ф-ии то какие собственно данные будут выводится, из БД или Веб
	//вы делаете костыли
	//если вы хотите получить данные из БД вводите true 
	ShowInfo(true);//все работает все прекрастно, но тут начальство и заказчик объявляют, что в будущем планируется куча ф-ий такого же типа

	//по итогу bool не подходит запускаем int, но ведь это не удобно, ведь тогда все комбинацие нужно знать!
	//и вот тут указатель на ф-ию спасет наше положение

	ShowInfo(DataFromWeb);		//магия
}
