#include<iostream> 
using namespace std;

//файл связан с предыдщим 27 файлом, имей в виду, часть кода из 27 нужна и тут!!!

void main()
{
	setlocale(LC_ALL, "Rus");     

  
	cout << "что такое nullptr (нул поинтер) и просто NULL" << NEW_LINE;
	//итак есть одно но, вспомни как мы работали с delete,
	//да мы удалили данные,но никто не мешает нам уже ВРУЧНУЮ туда что нибудь написать, или что то изменить! Это утечка памяти! Это плохо!
	cout << *ps << NEW_LINE; //афигел? я тоже || кстати не пытайся никогда удалить один элемент два раза, будет печально
	/*		немного отойдем от курса
	если nullptr является отдельным типом данных, и он прям реально НИЧЕГО

	то вот просто NULL это все же что-то, и это печально (по сути это просто 0), в этом можно даже убедится, напиши NULL навед на него курсор, F12
	ты увидишь #define NULL 0 , эта запись значит что все NULL заменяются на 0
	*/
	//однако если присвоить нашему ps=NULL, то он заставит ps забыть какой у нее был адрес, что она писала и т.д.
	ps = 0;
	delete ps; //как видишь мы удалили второй раз, но все норм! ведь 0 сменил значение на 0, следовательно delete ничего не будет чистить

	ps = nullptr; //теперь это не нолик которого мы знали, это что-то хуже. Но ведь если через отладчик посмотреть ничего не изменилось
	//изменилось
	//nullptr это отдельеый тип данных, его компилятор никогда ни с чем не спутает! Поэтому лучше использовать всегда его

	//если вы хотите убрать утечку данных прям основательно то сначада сделайте delete а потом присвойте указателю nullptr
	//НИКАК НЕ НАОБОРОТ, иначе вы не почините утечку памяти, а сделаете ее больше
	//вы стерете адрес,да, НО НЕ УДАЛИТЕ ДАНННЫЕ ПО ЭТОМУ АДРЕСУ, и delete просто увидит, адрем пуст, ладно, и данные в динамич. памяти будут висеть
	
	//продолжение в begginerC_code/dinamic
}
